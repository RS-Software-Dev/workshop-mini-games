<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brick Break Game</title>

    <style>
        body {
            background-color: black;
            color: white;
            font-family: monospace;
        }

        main,
        header {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 24px;
        }

        canvas {
            border: 2px solid white;
        }

        button {
            background-color: #333;
            color: white;
            border: 2px solid white;
            padding: 12px 24px;
            font-family: monospace;
            font-size: 16px;
            cursor: pointer;
        }

        button:hover {
            background-color: #555;
        }

        .game-over {
            color: red;
            font-size: 24px;
            font-weight: bold;
        }

        .win {
            color: lime;
            font-size: 24px;
            font-weight: bold;
        }
    </style>

    <script>
        class GameGrid {
            constructor({ rows, cols, cell }) {
                this.rows = rows
                this.cols = cols
                this.vals = []

                for (let row = 0; row < rows; row++) {
                    this.vals[row] = [];
                    for (let col = 0; col < cols; col++) {
                        this.vals[row][col] = cell(row, col);
                    }
                }
            }

            getCell({ row, col }) {
                if (0 <= row && row < this.rows && 0 <= col && col < this.cols) {
                    return this.vals[row][col]
                }
                return undefined
            }

            setCell({ row, col, value }) {
                if (0 <= row && row < this.rows && 0 <= col && col < this.cols) {
                    this.vals[row][col] = value
                }
            }
        }
    </script>

    <script>
        class BrickBreakState {
            constructor({ rows, cols, tileSize }) {
                this.rows = rows
                this.cols = cols
                this.tileSize = tileSize
                this.width = cols * tileSize
                this.height = rows * tileSize
                
                this.paddle = {
                    x: this.width / 2,
                    y: this.height - 30,
                    width: 80,
                    height: 15,
                    speed: 6
                }
                
                this.ball = {
                    x: this.width / 2,
                    y: this.height - 50,
                    radius: 8,
                    dx: 4,
                    dy: -4
                }
                
                this.bricks = this.createBricks()
                this.gameOver = false
                this.won = false
                this.score = 0
                this.paddleMove = 0
            }

            createBricks() {
                const bricks = []
                const brickRows = 5
                const brickCols = this.cols
                const colors = ['red', 'orange', 'yellow', 'green', 'blue']
                
                for (let row = 2; row < 2 + brickRows; row++) {
                    for (let col = 0; col < brickCols; col++) {
                        bricks.push({
                            row,
                            col,
                            color: colors[row - 2],
                            alive: true
                        })
                    }
                }
                return bricks
            }

            getBrickGrid() {
                const grid = new GameGrid({
                    rows: this.rows,
                    cols: this.cols,
                    cell: () => ({ type: 'empty' })
                })

                this.bricks.forEach(brick => {
                    if (brick.alive) {
                        grid.setCell({ 
                            row: brick.row, 
                            col: brick.col, 
                            value: { type: 'brick', color: brick.color }
                        })
                    }
                })

                return grid
            }
        }
    </script>

    <script>
        function updateBrickBreak(state) {
            if (state.gameOver || state.won) return state

            const newState = new BrickBreakState({ 
                rows: state.rows, 
                cols: state.cols,
                tileSize: state.tileSize 
            })
            newState.paddle = { ...state.paddle }
            newState.ball = { ...state.ball }
            newState.bricks = state.bricks.map(b => ({ ...b }))
            newState.score = state.score
            newState.paddleMove = state.paddleMove

            // Move paddle
            if (newState.paddleMove !== 0) {
                newState.paddle.x += newState.paddleMove * newState.paddle.speed
                
                // Keep paddle in bounds
                if (newState.paddle.x < newState.paddle.width / 2) {
                    newState.paddle.x = newState.paddle.width / 2
                }
                if (newState.paddle.x > newState.width - newState.paddle.width / 2) {
                    newState.paddle.x = newState.width - newState.paddle.width / 2
                }
            }

            // Move ball
            newState.ball.x += newState.ball.dx
            newState.ball.y += newState.ball.dy

            // Ball collision with walls
            if (newState.ball.x - newState.ball.radius <= 0 || 
                newState.ball.x + newState.ball.radius >= newState.width) {
                newState.ball.dx = -newState.ball.dx
                newState.ball.x = Math.max(newState.ball.radius, 
                    Math.min(newState.width - newState.ball.radius, newState.ball.x))
            }

            if (newState.ball.y - newState.ball.radius <= 0) {
                newState.ball.dy = -newState.ball.dy
                newState.ball.y = newState.ball.radius
            }

            // Ball collision with paddle
            if (newState.ball.y + newState.ball.radius >= newState.paddle.y - newState.paddle.height / 2 &&
                newState.ball.y - newState.ball.radius <= newState.paddle.y + newState.paddle.height / 2 &&
                newState.ball.x >= newState.paddle.x - newState.paddle.width / 2 &&
                newState.ball.x <= newState.paddle.x + newState.paddle.width / 2) {
                
                newState.ball.dy = -Math.abs(newState.ball.dy)
                newState.ball.y = newState.paddle.y - newState.paddle.height / 2 - newState.ball.radius
                
                // Add angle based on where ball hits paddle
                const hitPos = (newState.ball.x - newState.paddle.x) / (newState.paddle.width / 2)
                newState.ball.dx = hitPos * 4
            }

            // Ball falls below paddle
            if (newState.ball.y > newState.height) {
                newState.gameOver = true
                return newState
            }

            // Ball collision with bricks
            for (let brick of newState.bricks) {
                if (!brick.alive) continue

                const brickX = brick.col * newState.tileSize + newState.tileSize / 2
                const brickY = brick.row * newState.tileSize + newState.tileSize / 2
                const brickWidth = newState.tileSize - 2
                const brickHeight = newState.tileSize - 2

                // Check if ball intersects with brick
                if (newState.ball.x + newState.ball.radius >= brickX - brickWidth / 2 &&
                    newState.ball.x - newState.ball.radius <= brickX + brickWidth / 2 &&
                    newState.ball.y + newState.ball.radius >= brickY - brickHeight / 2 &&
                    newState.ball.y - newState.ball.radius <= brickY + brickHeight / 2) {
                    
                    brick.alive = false
                    newState.score += 10

                    // Determine bounce direction based on which side was hit
                    const ballCenterX = newState.ball.x - brickX
                    const ballCenterY = newState.ball.y - brickY
                    
                    if (Math.abs(ballCenterX) > Math.abs(ballCenterY)) {
                        newState.ball.dx = -newState.ball.dx
                    } else {
                        newState.ball.dy = -newState.ball.dy
                    }
                    break
                }
            }

            // Check win condition
            if (newState.bricks.every(b => !b.alive)) {
                newState.won = true
            }

            return newState
        }
    </script>

    <script>
        class CanvasRenderer {
            constructor({ canvas, tileSize, cellRenderer }) {
                this.canvas = canvas
                this.tileSize = tileSize
                this.context = canvas.getContext('2d')
                this.cellRenderer = cellRenderer
            }

            centerInCell({ row, col, draw }) {
                this.context.save()
                this.context.translate(
                    col * this.tileSize + this.tileSize / 2,
                    row * this.tileSize + this.tileSize / 2
                )
                draw()
                this.context.restore()
            }

            fillQuad(size) {
                this.context.beginPath()
                this.context.roundRect(-size / 2, -size / 2, size, size, size / 4)
                this.context.fill()
                this.context.closePath()
            }

            renderGrid(grid) {
                for (let row = 0; row < grid.rows; row++) {
                    for (let col = 0; col < grid.cols; col++) {
                        const cell = grid.getCell({ row, col })
                        
                        this.centerInCell({
                            row, col,
                            draw: () => {
                                this.cellRenderer.render(cell, this.context, {
                                    fillQuad: (size) => this.fillQuad(size),
                                    tileSize: this.tileSize
                                })
                            }
                        })
                    }
                }
            }

            render(state) {
                this.context.reset()
                this.context.fillStyle = '#111'
                this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)

                // Render bricks using grid
                this.renderGrid(state.getBrickGrid())

                // Render paddle (smooth position)
                this.context.fillStyle = 'white'
                this.context.fillRect(
                    state.paddle.x - state.paddle.width / 2,
                    state.paddle.y - state.paddle.height / 2,
                    state.paddle.width,
                    state.paddle.height
                )

                // Render ball (smooth position)
                this.context.fillStyle = 'cyan'
                this.context.beginPath()
                this.context.arc(state.ball.x, state.ball.y, state.ball.radius, 0, Math.PI * 2)
                this.context.fill()
                this.context.closePath()
            }
        }

        CanvasRenderer.auto = ({ rows, cols, tileSize, cellRenderer }) => {
            const canvas = document.createElement('canvas')
            canvas.width = cols * tileSize
            canvas.height = rows * tileSize
            return new CanvasRenderer({ canvas, tileSize, cellRenderer })
        }

        CanvasRenderer.appendAuto = ({parent, rows, cols, tileSize, cellRenderer}) => {
            let renderer = CanvasRenderer.auto({
                rows,
                cols,
                tileSize,
                cellRenderer
            })

            parent.append(renderer.canvas)
            return renderer
        }
    </script>

    <script>
        class BrickBreakCellRenderer {
            render(cell, context, helpers) {
                if (cell.type === 'empty') return

                if (cell.type === 'brick') {
                    context.fillStyle = cell.color
                    helpers.fillQuad(helpers.tileSize - 2)
                }
            }
        }
    </script>

    <script>
        class GameLoop {
            constructor({ launch, render, update, tickRate }) {
                this.launch = launch
                this.render = render
                this.update = update
                this.tickRate = tickRate || 1000
                this.intervalId = null
                this.state = null
            }

            run() {
                this.state = this.launch()
                this.render(this.state)

                let next = () => {
                    this.state = this.update(this.state)
                    this.render(this.state)
                    
                    if ((this.state.gameOver || this.state.won) && this.intervalId) {
                        clearInterval(this.intervalId)
                        this.intervalId = null
                    }
                }

                this.intervalId = setInterval(next, this.tickRate)
            }

            stop() {
                if (this.intervalId) {
                    clearInterval(this.intervalId)
                    this.intervalId = null
                }
            }

            restart() {
                this.stop()
                this.run()
            }
        }
    </script>

    <script>
        class HtmlRenderer {
            constructor({ container, template }) {
                this.container = container
                this.template = template
            }

            render(state) {
                this.container.innerHTML = this.template(state)
            }
        }

        HtmlRenderer.append = ({ parent, template }) => {
            let div = document.createElement('div')
            parent.append(div)
            return new HtmlRenderer({ container: div, template })
        }
    </script>
</head>

<body>
    <header>
        <h1>Brick Break Game</h1>
        <p>Use Arrow Keys or A/D to move paddle</p>
    </header>

    <main>
    </main>

    <script>
        const ROWS = 25
        const COLS = 30
        const TILE_SIZE = 20

        const main = document.querySelector('main')

        const canvasRenderer = CanvasRenderer.appendAuto({
            parent: main,
            rows: ROWS,
            cols: COLS,
            tileSize: TILE_SIZE,
            cellRenderer: new BrickBreakCellRenderer
        })

        const statsRenderer = HtmlRenderer.append({
            parent: main,
            template: (state) => {
                const aliveBricks = state.bricks.filter(b => b.alive).length
                return `
                <table>
                    <tbody>
                        <tr>
                            <th>Score:</th>
                            <td>${state.score}</td>
                        </tr>
                        <tr>
                            <th>Bricks Left:</th>
                            <td>${aliveBricks}</td>
                        </tr>
                        ${state.gameOver ? '<tr><td colspan="2" class="game-over">GAME OVER!</td></tr>' : ''}
                        ${state.won ? '<tr><td colspan="2" class="win">YOU WIN!</td></tr>' : ''}
                    </tbody>
                </table>
                ${(state.gameOver || state.won) ? '<button id="restart-btn">Restart Game</button>' : ''}
                `
            }
        })

        const loop = new GameLoop({
            launch: () => new BrickBreakState({ 
                rows: ROWS, 
                cols: COLS,
                tileSize: TILE_SIZE 
            }),
            render: (state) => {
                canvasRenderer.render(state)
                statsRenderer.render(state)

                if (state.gameOver || state.won) {
                    const btn = document.getElementById('restart-btn')
                    if (btn) {
                        btn.onclick = () => loop.restart()
                    }
                }
            },
            update: updateBrickBreak,
            tickRate: 16 // ~60 FPS for smooth movement
        })

        // Input handling
        const keys = {}
        
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true
            updatePaddleMove()
        })

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false
            updatePaddleMove()
        })

        function updatePaddleMove() {
            if (!loop.state) return

            const leftPressed = keys['arrowleft'] || keys['a']
            const rightPressed = keys['arrowright'] || keys['d']

            if (leftPressed && !rightPressed) {
                loop.state.paddleMove = -1
            } else if (rightPressed && !leftPressed) {
                loop.state.paddleMove = 1
            } else {
                loop.state.paddleMove = 0
            }
        }

        loop.run()
    </script>
</body>

</html>